#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass article
\begin_preamble
\usepackage[T1]{fontenc}
\usepackage{charter}
\usepackage{enumitem}
% Descriptions
%\setlist[description]{leftmargin=8em,style=nextline, ,font=\texttt}
%\setlist[description]{style=multiline,leftmargin=3cm}
%\setlist[description]{
%	leftmargin=\dimexpr\widest+0.5em\relax,
%	labelindent=0pt,
%	style=multiline,leftmargin=10cm,
%	labelwidth=\widest
%}
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language spanish
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures false
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 2cm
\topmargin 2cm
\rightmargin 2cm
\bottommargin 2cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style swiss
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Algoritmo Rápido de Reducción de Trajectorias de Plegamiento de Proteínas
\end_layout

\begin_layout Abstract
En los últimos años se ha logrando realizar simulaciones de plegamiento
 de proteínas mucho más largas que llegan al orden de los milisegundos,
 lo que antes no se había realizado principalmente debido a las limitaciones
 en los recursos computacionales.
 Muchas de estos datos de trayectorias de plegamiento se están colocando
 a disposición pública para que sean analizados, sin embargo, debido a la
 inmensa cantidad de conformaciones de proteínas que resultan en estas trayector
ias, su análisis se vuelve complejo.
 Por lo tanto, se vuelve necesario el desarrollo de métodos que logren obtener
 las conformaciones o grupos de conformaciones más representativas de la
 trayectoria teniendo en cuenta dos aspectos claves: el tiempo computacional
 y la calidad de los datos.
 En este trabajo, nosotros presentamos un algoritmo y una herramienta que
 realiza esta reducción de las trayectorias de plegamiento de proteínas
 teniendo en cuenta los dos aspectos anteriores.
 
\end_layout

\begin_layout Section*
Introducción
\end_layout

\begin_layout Standard
Actualmente se están liberando con más frecuencia datos de simulaciones
 de plegamiento de proteínas para que la comunidad científica los analice
 y avance en el entendimiento de este proceso.
 Estas simulaciones alcanzan tiempos de simulación que antes no se lograban
 debido a las limitaciones en los recursos computacionales.
 Hace algunos años el proyecto folding@home 
\begin_inset CommandInset citation
LatexCommand cite
key "PandeEnsign07"
literal "true"

\end_inset

 liberó varias trayectorias de la simulación de la proteína Villin Headpiece
 la cual alcanzó el orden de los microsegundos utilizando computación distribuid
a.
 Más recientemente, el grupo de David Shaw liberó simulaciones de varias
 proteínas en el orden de los milisegundos utilizando la supercomputadora
 Anton diseñada especialmente para simular dinámica molecular 
\begin_inset CommandInset citation
LatexCommand cite
key "Shaw2011,Shaw2008"
literal "true"

\end_inset

.
 Todas estas simulaciones se caracterizan por generar trayectorias que abarcan
 miles o millones de conformaciones, lo cual es una gran ventaja porque
 se tiene más detalle del proceso, pero así mismo es un problema debido
 al tiempo y recursos computacionales necesarios para analizarlas.
 
\end_layout

\begin_layout Standard
Para reducir estas trayectorias los métodos actuales buscan conjuntos de
 conformaciones representativas, que generalmente utilizan métodos de agrupamien
to donde se construye una matriz con las distancias entre cada una de las
 conformaciones, usualmente se usa la distancia conocida como RMSD o 
\emph on
Root Mean Square-Deviation
\emph default
.
 Estos agrupamientos se vuelven muy costosos en tiempo y recursos computacionale
s cuando se trata de muchas conformaciones y por esta razón los algoritmos
 buscan simplificar estos costos, como por ejemplo, reducir el número de
 átomos que comparar en las conformaciones (solo carbonos alfa).
 
\end_layout

\begin_layout Standard
Otra forma de reducir estas trayectorias es crear agrupamientos rápidos
 que no tengan que comparar todas las conformaciones, parecido a lo que
 realiza el algoritmo de Hobohm&Sander 
\begin_inset CommandInset citation
LatexCommand cite
key "Hobohm1992"
literal "true"

\end_inset

 para comparar secuencias de ADN.
 En este trabajo presentamos un algoritmo rápido para reducción de trayectorias
 de plegamiento de proteínas que toma como base la idea del algoritmo de
 Hobohm&Sander y que se basa en tres estrategias: primero una partición
 de la trayectoria en múltiples secciones; segundo, una reducción local
 muy rápida sobre cada una de ellas que aprovecha el tiempo de ocurrencia
 de las conformaciones; y tercero, una reducción global que busca encontrar
 las conformaciones más representativas de cada partición.
 Estas tres estrategias permiten que este algoritmo sea fácilmente paralelizable
, obtenga unos resultados previos de forma rápida, y de esos resultados
 seleccione los más importantes.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout

\series bold
Intros:
\end_layout

\begin_layout Itemize

\series bold
Yang2010:
\end_layout

\begin_deeper
\begin_layout Plain Layout
How does a protein fold into its biologically functional three-dimensional
 (3D) structure? This problem remains one of the greatest challenges in
 structural biology [Dill & Chan 1997, Dobson 2003,].
 However, recent advances in experimental technologies and computational
 theories have led researchers closer to solving this problem [Dinner et
 al.
 2000, Pande, 2003, Onuchic & Wolynes, 2004].
 Specifically, computer simulations based on theories in molecular dynamics
 have allowed scientists to gain insights into the folding process at an
 unprecedented temporal and spatial resolution, for instance, at the atomistic
 level with femtosecond (10-15 s) scale [Dauber-Osguthorpe et al.
 1996, Raman et al.
 2008, Snow et al., 2002, van der Spoel & Seibert 2006, Wallin & Shakhnovich
 2008].
 The product of such simulations is a collection of folding trajectories
 of the protein under study, where each trajectory consists of an ordered
 sequence of 3D structures sampled during the folding simulation.
 In this article, we refer to each 3D structure on a trajectory as a frame.
 A trajectory essentially depicts the evolving path that a protein acquires
 its final 3D structure from an initially random structure.
 Figure 1 illustrates four frames along a folding trajectory of a designed
 protein Beta3S.
 By analyzing these folding trajectories, researchers have gained invaluable
 insights in understanding the nature of the folding process such as key
 residues [Vendruscol et al., 2001] and different folding mechanisms (e.g.,
 the nucleation-condensation model [White et al., 2005]).
 These findings have also been subsequently verified by experimental methods.
\end_layout

\end_deeper
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Subsection
Contexto
\end_layout

\begin_layout Itemize
El plegamiento de proteínas es un proceso que puede llevarle a la proteína
 algunos milisegundos pero que al simularlo computacionalmente podría abarcar
 tiempos supremamente mayores de días o meses.
 Hasta hace algunos años las simulaciones reportadas eran de la escala de
 algunos nanosegundos a microsegundos, sin embargo esto ha ido cambiando
 con el surgimiento de nuevas técnicas y supercomputadoras diseñadas especialmen
te para este tipo de simulaciones.
 Por ejemplo, el proyecto folding@home [1], empleando una nueva técnica
 de computación distribuida, a simulado el plegamiento de proteínas pequeñas
 (36 residuos) en el orden de microsegundos (500 us), lo cual hasta hace
 algunos años eran escalas de tiempo imposible de alcanzar.
 Así mismo, la supercomputador Anton [2], diseñada especialmente para este
 tipo de simulaciones, ha logrado simular el plegamiento de varias proteínas
 (de 10 a 92 residuos) en el orden de los milisegundos.
 
\end_layout

\begin_layout Itemize
Todas estas simulaciones producen miles o millones de conformaciones o 
\emph on
snapshots
\emph default
 que para su análisis computacional se necesita gran cantidad de tiempo
 de máquina y recursos computacionales que muchas veces o son muy extensos
 (horas o días) o no están disponibles fácilmente (supercomputadoras o clusters).
 Par 
\end_layout

\begin_layout Itemize
que pueden no estar disponibles y por lo tanto se necesita reducir esas
 trayectorias 
\end_layout

\begin_layout Itemize
Dependiendo del nivel de detalle con el que se quiera estudiar el plegamiento,
 
\end_layout

\begin_layout Itemize
Con la 
\end_layout

\begin_layout Itemize
\begin_inset Note Note
status open

\begin_layout Itemize
El procesamiento de grandes volúmenes de datos es generalmente un reto cuando
 se trabaja en problemas de bioinformática.
\end_layout

\begin_layout Itemize
La evolución de las técnicas ha conducido a que actualmente la disposición
 de datos biológicos sea masiva.
 
\end_layout

\begin_layout Itemize
El desafío ahora es evolucionar tanto en hardware como en software de una
 manera tal que dichos datos se puedan procesar y obtener así información
 con un sentido biológico
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
El supercomputador Anton es una máquina especialmente diseñada para simular
 el plegamiento de la proteína, es decir simular los cambios en la estructura
 tridimensional de una proteína en un periodo de un milisegundo, la cual
 es una escala bastante superior comparado con simulaciones realizadas utilizand
o otras técnicas y recursos.
\end_layout

\begin_layout Itemize
Los resultados obtenidos se representan con la trayectoria de la proteína,
 es decir, cientos o miles de secuencias de proteínas que indican la posición
 de cada uno de sus átomos en un instante de tiempo.
\end_layout

\begin_layout Itemize
En el caso de las proteínas el caso no es la excepción.
 Cada vez más se tiene acceso a servidores con gran cantidad de secuencias
 de proteínas listas para ser procesadas y analizadas.
 Algunos centros de investigación, que cuentan con gran capacidad de cómputo,
 colocan a disposición de la comunidad científica datos que han sido procesados
 en sus máquinas, los cuales pueden ser accesados libremente a través de
 una descarga o previa solicitud de los centros.
\end_layout

\end_inset


\end_layout

\begin_layout Section
Antecedentes
\end_layout

\begin_layout Standard
La reducción de trayectorías se ha enfocado principalmente a dos ve
\end_layout

\begin_layout Standard
La mayoría de trabajos que encontramos están orientados a la reducción de
 trayectorias de plegamiento a través de la selección de las características
 principales que resumen la trayectoría, por ejemplo......
 Sin embargo, nuestro enfoque es diferente al de estos trabajos ya que nosotros
 nos enfocamos en seleccionar las estructuras más representativas de la
 trayectoría y que en últimas representan también un resumen de la misma.
 Algo parecido pero no igual a nuestro enfoque es lo que muchas de las herramien
tas de simulación de plegamiento ofrecen en la selección de los tiempos
 de paso (
\emph on
time steps
\emph default
) en los cuales se toman los 
\emph on
snapshots 
\emph default
o la estructura correspondiente en esos tiempos.
 Nuestro enfoque trabaja sobre las trayectorias de plegamiento ya realizadas
 y disponibles como un conjunto de snapshots a determinado 
\emph on
time step 
\emph default
y sobre estás realiza la selección de las más representativas por segmentos
 de tiempo que se ingresan como parámetros.
 El resultado es otra trayectoría con estructuras que representan de forma
 resumidad la trayectoria original y que contiene los evento o estructuras
 principales.
 El algoritmo se puede ajustar con diferentes parámetros para definir el
 tamaño de las particiones en número de conformaciones y número de representativ
as por cada partición, por ejemplo se puede definir que cada 1000 conformaciones
 se seleccionen 500 representativas, lo que reduce a la mitad el número
 de conformaciones, o cada 10000 conformaciones se selecciones 100, lo que
 la reduce a la trayectoria en 99%.
\end_layout

\begin_layout Standard
Rajan
\end_layout

\begin_layout Subsection
Yang2007
\end_layout

\begin_layout Standard
Yang et al.
 2007 
\begin_inset CommandInset citation
LatexCommand cite
key "Yang2007"
literal "false"

\end_inset

 usa mapas de contacto 2D (matrices de distancias binaria) para representar
 las estructuras 3D de las trayectoria de plegamiento a través de lo que
 ellos definen como patrones de objetos asociados espacialmente o 
\emph on
SOAPs.

\emph default
 Estos SOAPs representan los patrones 2D no locales que se encuentran en
 los mapas de contacto de la estructura de las proteínas.
 Se encuentran los SOAPs de todas las estructuras de la trayectoria, se
 los agrupa por SOAPs comúnes de acuerdo a una medida de distancia, y se
 obtienen los más representativos o más frecuentes.
 Entonces el proceso de reducción propuesto por los autores consiste en
 representar la estructura de la proteína con los SOAPs más característicos
 que esta contenga, es decir, partes de la estructura que no correspondan
 a un SOAP frecuente no van en la representación, lo que segun ĺo autores
 lleva a una representación más concisa de la estructura de la proteína
 y por consiguiente a una reducción en toda la trayectoria.
 Esta forma de reducción la utilizan para análizar el plegamiento de proteínas
 y caracterizar los motivos 3D asociados a SOAPs que se producen durante
 el plegamiento y como estos se mantiene o desaparecen en el plegamiento
 de proteínas específicas.
 Sin embargo, la reducción cambia sustancialmente los elementos de la trayectori
a al trasladar las estructuras 3D a representaciones 2D, y de alguna forma
 se pierde información implicita en la estructura.
\end_layout

\begin_layout Subsection
Rajan
\end_layout

\begin_layout Standard
Rajan et al.
 2010 
\begin_inset CommandInset citation
LatexCommand cite
key "RajanSchulten10"
literal "false"

\end_inset

 adaptan un método de escalamiento multidimensional no métrico (
\emph on
nMDS)
\emph default
 para obtener una representación reducida 2D de toda la trayectoria.
 Inicialmente transforman la estructura 3D de la proteina a sus respectivos
 ángulos dihédricos para luego aplicarles el método de escalamiento y obtener
 un conjunto de puntos que representa las estructuras de proteínas.
 Estos puntos se despliegan sobre un espacio métrico (generalmente 2D) que
 representa la trayectoria de tal manera que la distancia cada par de puntos
 
\emph on
x,y
\emph default
 es consistente con las distancias de cada par de estructuras 
\emph on
X,Y
\emph default
 representadas por los respectivos puntos.
 Aunque esta forma de reducción simplifica a 2D las estructuras N dimensionales
 (N coordenadas XYZ de sus átomos), la información de la estructura se sigue
 perdiento y la reducción se vuelve específica para ciertos análisis como
 el descrito en el artículo de observar el orden de formación de estructuras
 secundarias.
\end_layout

\begin_layout Subsection
Otros
\end_layout

\begin_layout Standard
Una de las técnicas más usuadas para reducción de trayectorias de simulación
 de plegamiento de proteínas ha sido el análisis de componentes principales
 (PCA) 
\begin_inset CommandInset citation
LatexCommand cite
key "Duan2013"
literal "false"

\end_inset

, el cual transforma la estructura de la proteína desde un espacio N-dimensional
–dado por los puntos de datos representados por las N coordenadas de sus
 átomos–a un espacio lineal K-dimensional (K < D) que corresponde a un nuevo
 sistema de coordenadas llamado componentes principales.
 Estos componentes representan los vectores tangentes que describen un hiperplan
o que pasa a través de los puntos de datos tanto como sea posible cuando
 se evalúan sus mínimos cuadrados.
 Estos componentes se ordenan de acuerdo a su varianza y los primeros componente
s (mayor varianza) son los más importantes y que resumen los cambios conformacio
nales globales de la proteína.
 Sin embargo PCA tiene problemas cuando los espacios son no-lineales, como
 se piensa que es el espacio conformacional de la proteína y por lo tanto
 el nuevo espacio K-dimensional puede resultar distorsionado 
\begin_inset CommandInset citation
LatexCommand cite
key "Das2006"
literal "false"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Itemize

\series bold
Yang2007
\series default
: In A Spatio-temporal Mining Approach towards Summarizing and Analyzing
 Protein Folding Trajectories, Hui Yang, Srinivasan Parthasarathy and Duygu
 Ucar [6], describe a method to mine protein folding molecular dynamics
 simulations datasets.
 They describe a spatio-temporal association discovery approach to mine
 protein folding trajectories, to identify critical events and common pathways.
\end_layout

\begin_layout Itemize

\series bold
Yang2007:
\series default
 Clearly, protein folding trajectories consist of both spatial and temporal
 components.
 Each protein in a MD simula- tion is composed of a number of residues spatially
 located in the 3D space that move over time.
 Each frame (or snap- shot) of the trajectory can be represented as a 2D
 contact map, which captures the pair-wise 3D distances between residues.
 We extract non-local bit-patterns from these con-tact maps.
 We then use an entropy-based clustering algo-rithm to cluster such bit-patterns
 yinto groups.
 These bit-patterns are further associated to form spatial object asso-ciation
 patterns (SOAPs).
 By using SOAPs, we are able to effectively summarize and analyze folding
 trajectories produced by MD simulations.
 A major advantage of this representation is its appropriateness for cross-compa
rison across different simulations, as discussed in later sections.
\end_layout

\begin_layout Itemize

\series bold
Yang2010: 
\series default
In this step, we first transform a folding trajectory from a series of 3D
 structures to a series of 2D contact maps.
 We then define the concept of 2D non-local patterns and consequently extract
 them.
 Finally, we categorize these 2D patterns into different groups such that
 the patterns in the same group are approximately similar to each other
 based on their geometric features.
 Note that Yang et al.
 first introduced such 2D non-local patterns and applied them for protein
 folding data analysis [Yang et al., 2007].
 We include them here to make this algorithm self-contained and to facilitate
 our discussion on the importance of this step towards the identification
 of 3D structural motifs.
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Simulaciones de Plegamiento
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Itemize

\series bold
[lgarreta2015]
\series default
: Several computational approaches for simulating protein folding and molec-
 ular motion have been applied to protein folding [Pande et al., 2008, Javidpour,
 2012], from atomistic representations as Molecular Dynamics (MD) to reduced
 representations based on sampling techniques as the Probabilistic Roadmap
 Method (PRM) (see chapter 2 for a description of both methods).
 In our research, we used mainly the folding data from two projects: the
 MD tra- jectories of the villin-headpiece protein from the folding@home
 project; and the folding pathways of several proteins generated with the
 PRM implemented in the Parasol Folding Server.
\end_layout

\begin_layout Itemize
An MD computation simulates the motion of a collection of atoms (the chemical
 system) over a period of time accord- ing to the laws of classical physics.1
 Time is broken into a series of discrete time steps, each representing
 a few fem- toseconds of simulated time.
 A time step has two major phases.
 Force calculation computes the force on each par- ticle due to other particles
 in the system.
 Integration uses the net force on each particle to update that particle’s
 posi- tion and velocity [Shaw08]
\end_layout

\begin_layout Itemize

\series bold
Yang2007:
\series default
 Protein Folding Trajectories Advances in high-performance computing technologie
s and molecular dynamics have led to successful simula- tions of folding
 dynamics for (small) proteins at the ato- mistic level [8].
 Such simulations result in a large number of folding trajectories, each
 of which consists of a series of 3D conformations of the protein under
 simulation.
 These conformations are usually sampled regularly (e.g., every 200fs) during
 a simulation.
 In this article, we also refer to each conformation as a folding frame
 or simply a frame.
 Furthermore, to represent a protein conformation, we adopt one of the commonly
 adopted representation schemes, where a conformation is represented as
 a sequence of α-carbons (Cα) located in 3D space.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Revisar secciones 2.7, especialmente la 2.7.1.
 de Tesis LG 
\begin_inset CommandInset citation
LatexCommand cite
key "Garreta2015"
literal "true"

\end_inset


\end_layout

\begin_layout Subsection
Simulaciones Largas de Plegamiento (MMart)
\end_layout

\begin_layout Standard
Las simulaciones del plegamiento de proteínas son complejas y demandan gran
 cantidad de tiempo y recursos computacionales.
 Debido a estas limitaciones tecnológicas, las simulaciones del plegamiento
 de proteínas hasta hace unos años se realizaban para proteínas pequeñas
 y los tiempos simulados eran muy cortos, en el orden de los microsegundos
 mientras que una proteína se pliega en el orden de los milisegundos 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cite{HuardWood06}
\end_layout

\end_inset

.
 Sin embargo, en los últimos años los avances en el hardware han logrado
 algunos avances de tal manera que se empiezan a mostrar resultados de simulacio
nes más largas y de proteínas más grandes.
 Dos ejemplos de estos avances son los proyectos de folding@home y de la
 supercomputadora Anton.
 El proyecto foldin@home logró realizar hace algunos años una de las primeras
 simulaciones largas utilizando computación distribuida.
 Una de sus simulaciones alcanzó el orden de los microsegundos para plegar
 completamente una proteína pequeña, la Villin Headpiece de 36 residuos
 
\begin_inset CommandInset citation
LatexCommand cite
key "LougherMarsder12"
literal "true"

\end_inset

.
 La supercomupatadora Anton es un proyecto más reciente (2010) que usa computaci
ón paralela y hardware especializado para simular dinámica molecular.
 Con está máquina se ha logrado plegar completamente varias proteínas medianas
 (10-80 residuos), alcanzando tiempos de simulación del orden de los milisegundo
s 
\begin_inset CommandInset citation
LatexCommand cite
key "Shaw08"
literal "true"

\end_inset

.
 En ambos proyectos los resultados de las trayectorias están disponibles
 para que la comunidad científica los descargue y los analice para avanzar
 en el entendimiento del plegamiento de las proteínas.
 
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Otras fuentes
\begin_inset CommandInset citation
LatexCommand cite
key "Wikipedia1963"
literal "true"

\end_inset

, 
\begin_inset CommandInset citation
LatexCommand cite
key "LougherMarsder12"
literal "true"

\end_inset


\end_layout

\end_inset

 
\end_layout

\begin_layout Subsection
Algoritmos Rápido de Agrupamiento de Hobohn y Sander
\end_layout

\begin_layout Standard
El algoritmo de Hobohm y Sander 
\begin_inset CommandInset citation
LatexCommand cite
key "Hobohm1992"
literal "true"

\end_inset

 se creó inicialmente para agrupar de forma rápida secuencias de proteínas.
 El algoritmo determina las secuencias más representativas a través de dos
 actividades: un ordenamiento y una selección rápida.
 En el ordenamiento, las secuencias se organizan por longitud en orden descendie
nte, luego se toma la primera secuencia (la más larga) como representativa
 del primer grupo.
 En la selección rápida, se compara el resto de secuencias con la representativa
 y se las incorpora al grupo si son cercanas (ejemplo, si son similares
 a nivel de secuencias), de lo contrario, pasa a ser la representativa de
 un nuevo grupo y se hace lo mismo con el resto de secuencias hasta terminar.
 
\end_layout

\begin_layout Standard
Los aspectos determinantes del éxito del algoritmo son la relación de orden
 que se establezca al inicio y las propiedades que se tomen para comparar
 las secuencias.
 En secuencias de ADN y de proteínas estos aspectos funcionan bien ya que
 dos secuencias de más o menos de igual longitud tienen mayor probabilidad
 de ser similares que dos secuencias de longitudes completamente diferentes.
 Sin embargo en estructuras tridimensionales de proteínas que pertenecen
 a una misma trayectoria, la longitud y la similaridad de la secuencia va
 a ser la misma para todas la conformaciones, lo que implica redefinir estos
 aspectos en términos de las características de las estructuras 3D de proteínas
 de una misma trayectoria, como vamos a describir más adelante cuando mostremos
 nuestro algoritmo de reducción de trayectorias de plegamiento.
\end_layout

\begin_layout Standard
Dos de las implementaciones más usadas de este algoritmo para agrupamiento
 rápido de secuencias son los programas CD-HIT 
\begin_inset CommandInset citation
LatexCommand cite
key "Weizhong2002"
literal "true"

\end_inset

 y UCLUST 
\begin_inset CommandInset citation
LatexCommand cite
key "Edgar2010"
literal "true"

\end_inset

.
 El programa CD-HIT realiza un ordenamiento por longitud de la secuencia
 como lo plantea el algoritmo de Hobhon, y para la selección utiliza un
 filtro de palabras cortas para comparar si dos secuencias son similares–evitand
o el alineamiento de las mismas–y así asignarlas a un mismo grupo o crear
 uno nuevo.
 En el caso de secuencias de proteínas el programa usa por defecto una palabra
 de 10 aminoácidos o 
\emph on
decapeptido
\emph default
.
 En cambio el programa UCLUST utiliza para com parar las secuencias una
 función creada por los mismos autores que la llaman como USEARCH y que
 calcula la similitud entre las secuencias a partir de un alineamiento global.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout

\series bold
Algoritmo de Hobhon y Sander
\end_layout

\begin_layout Description
Liu09: Hobohm and Sander’s algorithm sorts all sequences by length in descending
 order to generate an ordered sequen- ce set S.
 Then similar sequences will be put together into the same cluster.
 The longest sequence is added into the first cluster (initially empty),
 which is also the represen- tative of the cluster, and then all the other
 sequences are compared with the representative.
 If the similarity be- tween a sequence and the representative is above
 a thre- shold then it will be included into the same cluster as the representat
ive’s, otherwise a new cluster will be created with it as the representative.
 Every remaining sequence will be processed in the same way, either as the
 repre- sentative of a new cluster if the similarity between it and any
 representative is below the threshold, or included into some existing cluster
 if it is similar to the cluster’s representative.
 2.
\end_layout

\begin_layout Description
Weizhong02: According to this algorithm, a final clustered database is composed
 of representative sequences with pairwise similarities below a specified
 threshold.
 So a sequence having an identity greater than the threshold to a chosen
 representative is considered redundant and is removed from the database.
 Sequences are first sorted in order of decreasing length, and the longest
 sequence is selected as the first representative.
 Each remaining sequence is then compared to all the existing representatives,
 and if it is not redundant to all old representatives then it is added
 as a new representative.
 The sequence identity is computed as the number of identical residues in
 the alignment divided by the length of the shorter sequence.
 This algorithm guarantees that all representatives are compared and that
 all deleted sequences are compared to their corresponding representatives.
 It doesn’t care whether the non-representative sequences in the same cluster
 are similar or not.
 For example, two short se- quences can be aligned at different regions
 of a long representative sequence.
 Short-word
\end_layout

\begin_layout Description
Hobohm92: The first algorithm focuses on optimizing a par- ticular property
 of the selected proteins and works by successive selection of proteins
 from an ordered list and exclusion of all neighbors of each selected protein.
 The other algorithm aims at maximizing the size of the selected set and
 works by successive thinning out of clusters of similar proteins.
 Both algorithms are generally applicable to other data bases in which criteria
 of similarity can be defined and relate to problems in graph theory
\end_layout

\begin_layout Plain Layout
En el caso de estructuras de proteínas provenientes de trayectorias, la
 selección se puede realizar usando la distancia media cuadrática mínima
 o RMSD con umbrales muy altos, ya que dos conformaciones que ocurran muy
 cerca en el tiempo (eg.
 tn y tn+1) van a presentar cambios mínimos en su configuración (un leve
 desplazamiento de los átomos), y por lo tanto deberían estar en un mismo
 grupo.
 Sin embargo, si el umbral de RMSD se sobrepasa, esto indica que las conformacio
nes tiene diferencias apreciables y por lo tanto se debería iniciar otro
 grupo.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Description
Liu09: It uses short word filtering to deter- mine the similarity between
 two sequences rather than performing an actual sequence alignment.
 However, the results generated by short word filtering are not accurate
 to some degree.
 The lowest threshold of CD-HIT is around 40% and it is not suitable for
 removing redun- dancy on lower threshold.
 PISCES [7] is a public server for culling sets of protein sequences from
 the Protein Data Bank.
 It determines sequence similarity by PSI- BLAST [8] alignments which are
 more accurate, and it also uses a structural quality criterion to cull
 sequences from a sequence database.
\end_layout

\begin_layout Description
Liu09: FastCluster, introduced in this paper, uses BLAST [9] to determine
 sequence similarity, which is a general se- quence alignment tool and can
 provide better sequence similarity than word filtering.
 FastCluster makes im- provements to Hobohm and Sander’s algorithm and can
 get a larger non-redundant protein dataset, which means more protein families
 can be clustered.
\end_layout

\begin_layout Description
Li12a: Uclust [39] follows CD-HIT’s greedy incremental approaches, but it
 uses a heuristics called Usearch for fast sequence comparison.
 It also gains speed by com- paring a few top sequences instead of the full
 data- base.
 Uclust can run on DNA, protein and rRNA sequences.
 Currently, its 32-bit pre-compiled bin- aries are freely available from
 http://www.drive5 .com/usearch/.
 
\end_layout

\begin_layout Description
Li12a: DNACLUST [40] also follows greedy incremental approach; it uses a
 suffix array to index the input data set.
 Unlike CD-HIT and Uclust, which can process both proteins and DNAs, DNACLUST
 only works on DNA se- quences, and it is suitable for clustering highly
 similar DNAs, especially for rRNA tags.
 It is available as open source program at http://dnaclust.source forge.net/.
 SEED [41] only works with Illumina reads and only identifies up to three
 mismatches and three overhanging bases.
 It uses an open hashing technique and a special class of spaced seeds,
 called block spaced seed.
 SEED is also an open source soft- ware available at http://manuals.bioinformatic
s.ucr .edu/home/seed.
\end_layout

\end_inset


\end_layout

\begin_layout Section
Algoritmo de Reducción de Trayectorias de Plegamiento (LuisG)
\end_layout

\begin_layout Standard
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status collapsed

\begin_layout Plain Layout
La primera parte del algoritmo realiza un agrupamiento local rápido donde
 se aprovecha el ordenamiento temporal de las conformaciones implícito en
 la trayectoria.
 Pare esto, se toma la idea del algoritmo propuesto por Hobohm et al.
 [1] para la selección de conjuntos de proteínas.
 Se particiona la trayectoria en 
\emph on
M bins
\emph default
 o secciones de 
\emph on
N 
\emph default
conformaciones contiguas en el tiempo de simulación.
 Para cada uno de los 
\emph on
bins
\emph default
 se toma la primera estructura como cabeza del primer grupo y se la compara
 con la siguiente en orden de tiempo de simulación.
 Si presentan similaridad se adicionan al grupo; de lo contrario si es disimilar
 se crea un nuevo grupo y se toma a esta última estructura como cabeza del
 nuevo grupo.
 El proceso continua hasta terminar con todas las estructuras del 
\emph on
bin 
\emph default
y esto mismo se realiza para los demás 
\emph on
bins.

\emph default
 En la segunda parte del algoritmo, toma cada conjunto de conformaciones
 cabeza de grupo seleccionadas en cada 
\emph on
bin
\emph default
 y se crea una matriz de similaridades que se la usa para realizar un agrupamien
to para seleccionar las 
\emph on
K
\emph default
 estructuras más representativas de cada conjunto tomando los
\emph on
 k-medoides
\emph default
.
 La unión de estas 
\emph on
K
\emph default
 estructuras por 
\emph on
bin
\emph default
 crea un nuevo conjunto mucho más reducido que el creado en el agrupamiento
 local.
 El orden temporal no se pierde ya que las 
\emph on
K
\emph default
 estructuras seleccionadas por cada conjunto se las ordena de acuerdo a
 su tiempo original de simulación.
\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status collapsed

\begin_layout Itemize
Descripción general algoritmo:
\end_layout

\begin_deeper
\begin_layout Plain Layout
El algoritmo contiene tres fases: primero inicia particionando la trayectoria
 de plegamiento original en secciones o
\emph on
 bins
\emph default
 donde se ubican un número 
\emph on
N
\emph default
 de estructuras de proteínas contiguas en el tiempo.
 Sobre cada 
\emph on
bin
\emph default
 se aplica un agrupamiento local rápido (descrito abajo) y se obtiene un
 número mucho menor de estructuras representativas de ese 
\emph on
bin
\emph default
.
 Adicionalmente, sobre esa primera reducción se realiza un agrupamiento
 global detallado (descrito abajo) que simplifica cada 
\emph on
bin 
\emph default
a 
\emph on
K
\emph default
 representativas.
 Al final, se obtienen dos conjuntos de estructuras que corresponden a las
 dos reducciones, local y global de la trayectoria de plegamiento original.
\end_layout

\end_deeper
\begin_layout Itemize
Notas sobre paralelización del algoritmo
\end_layout

\begin_deeper
\begin_layout Plain Layout
El algoritmo es fácilmente paralelizable ya que una vez particionada la
 trayectoría el proceso de reducción es el mismo para cada sección o 
\emph on
bin, 
\emph default
lo que permite que el procesamiento se reparta sobre cada 
\emph on
bin
\emph default
, es decir, tanto la reducción local como la reducción global se ejecutan
 al mismo tiempo sobre cada 
\emph on
bin
\emph default
 y por lo tanto si existen 
\emph on
N
\emph default
 
\emph on
bins
\emph default
, cada uno de ellos se podría asignar a un proceso, hilo, o procesador.
\end_layout

\end_deeper
\begin_layout Itemize
Detalles de TM-score
\end_layout

\begin_deeper
\begin_layout Plain Layout
Grupos que también tiene en cuenta la posición de los átomos entre las estructur
as pero es menos sensible a las variaciones estructurales locales.
 La métrica para las comparaciones en esta fase es el TM-score que tiene
 en cuenta las propiedades globales de plegamiento y por lo tanto es adecuada
 para agrupar estructuras que están más alejadas o separadas tiempos más
 largos dentro de la trayectoria.
\end_layout

\begin_layout Plain Layout
En la segunda fase, el algoritmo toma las estructuras representativas de
 cada grupo y realiza con ellas un nuevo agrupamiento utilizando la métrica
 TM-score que tiene en cuenta propiedades globales del plegamiento y que
 no es tan sensible a variaciones locales como sucede con el RMSD.
 Este nuevo agrupamiento forma 
\emph on
K
\emph default
 grupos de los cuales se toman las estructuras centrales o medoides como
 representativas y que finalmente serán las que después del proceso de reducción
 representan a todo el 
\emph on
bin.
\end_layout

\end_deeper
\begin_layout Itemize
Detalles del agrupamiento lógico:
\end_layout

\begin_deeper
\begin_layout Plain Layout
Tomando la primera estructura del 
\emph on
bin 
\emph default
(estado inicial) como representativa del primer grupo.
 Después, la siguiente estructura dentro del 
\emph on
bin,
\emph default
 en orden de tiempo, se compara con la última representativa y si son semejantes
 de acuerdo a una métrica y a un umbral predeterminado, entonces la estructura
 se asigna a este grupo, de lo contrario se forma uno nuevo que toma a esta
 ultima estructura como la nueva representativa.
 La métrica para las comparaciones en esta fase es el 
\emph on
TM-score 
\emph default
que tiene en cuenta las propiedades globales de plegamiento y por lo tanto
 es adecuada para agrupar estructuras que están más alejadas o separadas
 tiempos más largos dentro de la trayectoria.
 Este proceso se sigue con las siguientes estructuras pero teniendo en cuenta
 que las comparaciones se realizan solo con las estructuras representativas
 de cada grupo y no con las estructuras que conforman el grupo, lo cual
 reduce el número de comparaciones en gran medida frente a un algoritmo
 convencional de agrupamiento.
 Además, para evitar más comparaciones, estas se realizan de atrás hacia
 adelante, es decir, las estructuras se comparan con la última representativa
 y si son semejantes entonces se agrega al grupo y no se siguen las comparacione
s.
 Esto debido a que a medida que avanza la simulación de plegamiento, una
 nueva estructura no es más que una modificación de la anterior y por lo
 tanto se espera que sea más semejante a esta última.
\end_layout

\end_deeper
\begin_layout Itemize
Descripción del particionamiento:
\end_layout

\begin_deeper
\begin_layout Plain Layout
Para la partición de la trayectoría se toma para cada 
\emph on
bin
\emph default
 un número 
\emph on
M
\emph default
 de estructuras contiguas en la trayectoría y se las asigna al 
\emph on
bin
\emph default
, de esta manera las primeras 
\emph on
M 
\emph default
estructuras se ubicarán en el bin1, las segunda 
\emph on
M
\emph default
 se ubicarán en el bin2, y así sucesivamente, creándose un número de 
\emph on
bins
\emph default
 igual al número total de estructuras sobre el tamaño 
\emph on
M
\emph default
 de estructuras por bin.
 Por ejemplo si la trayectoría tiene N=1000 estructuras y se escoje M=200,
 entonces se crearán K=5 
\emph on
bins,
\emph default
 cada uno con 200 estructuras (1000/2000.
 
\end_layout

\end_deeper
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Datos y Métodos (LuisG)
\end_layout

\begin_layout Subsection
Comparación de Estructuras de Proteínas
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\align center

\series bold
TMscore and other metrics for structural comparison:
\series default
 
\end_layout

\begin_layout Description
[
\begin_inset CommandInset citation
LatexCommand cite
key "Zhan2004"
literal "true"

\end_inset

Seminal
\begin_inset space ~
\end_inset

Paper] Scoring
\begin_inset space ~
\end_inset

function
\begin_inset space ~
\end_inset

for
\begin_inset space ~
\end_inset

automated
\begin_inset space ~
\end_inset

assessment
\begin_inset space ~
\end_inset

of
\begin_inset space ~
\end_inset

protein
\begin_inset space ~
\end_inset

structure
\begin_inset space ~
\end_inset

template
\begin_inset space ~
\end_inset

quality
\begin_inset space ~
\end_inset

Zhang
\begin_inset space ~
\end_inset

Y.
\begin_inset space ~
\end_inset

Skolnick
\begin_inset space ~
\end_inset

J.: We have developed a new scoring function, the template modeling score
 (TM-score), to assess the quality of protein structure templates and predicted
 full-length models by extending the approaches used in Global Distance
 Test (GDT) and MaxSub.
 First, a protein size-dependent scale is exploited to eliminate the inherent
 protein size dependence of the previous scores and appropriately account
 for random protein structure pairs.
 Second, rather than setting specific distance cutoffs and calculating only
 the fractions with errors below the cutoff, all residue pairs in alignment/mode
ling are evaluated in the proposed score.
 For comparison of various scoring functions, we have constructed a large-scale
 benchmark set of structure templates for 1489 small to medium size proteins
 using the threading program PROSPECTOR_3 and built the full-length models
 using MODELLER and TASSER.
 The TM-score of the initial threading alignments, compared to the GDT and
 MaxSub scoring functions, shows a much stronger correlation to the quality
 of the final full-length models.
 The TM-score is further exploited as an assessment of all 'new fold' targets
 in the recent CASP5 experiment and shows a close coincidence with the results
 of human-expert visual assessment.
 These data suggest that the TM-score is a useful complement to the fully
 automated assessment of protein structure predictions.
 © 2004 Wiley-Liss, Inc.
\end_layout

\begin_layout Description
[https://zhanglab.ccmb.med.umich.edu/TM-score/]: TM-score is a metric for measuring
 the structural similarity of two protein models.
 It is designed to solve two major problems in the traditional metrics such
 as root-mean-square deviation (RMSD): (1) TM-score measures the global
 fold similarity and is less sensitive to the local structural variations;
 (2) magnitude of TM-score for random structure pairs is length-independent.
 TM-score has the value in (0,1], where 1 indicates a perfect match between
 two structures.
 Following strict statistics of structures in the PDB, scores below 0.17
 corresponds to randomly chosen unrelated proteins whereas with a score
 higher than 0.5 assume generally the same fold in SCOP/CATH.
 
\end_layout

\begin_layout Description
[https://en.wikipedia.org/wiki/Template_modeling_score] bioinformatics, the
 template modeling score or TM-score is a measure of similarity between
 two protein structures with different tertiary structures.
 The TM-score is intended as a more accurate measure of the quality of full-leng
th protein structures than the often used RMSD and GDT measures.
 The TM-score indicates the difference between two structures by a score
 between ( 0 , 1 ] {
\backslash
displaystyle (0,1]} {
\backslash
displaystyle (0,1]}, where 1 indicates a perfect match between two structures
 (thus the higher the better).[1] Generally scores below 0.20 corresponds
 to randomly chosen unrelated proteins whereas structures with a score higher
 than 0.5 assume roughly the same fold.[2] A quantitative study [3] shows
 that proteins of TM-score = 0.5 have a posterior probability of 37% in the
 same CATH topology family and of 13% in the same SCOP fold family.
 The probabilities increase rapidly when TM-score > 0.5.
 The TM-score is designed to be independent of protein lengths.
 Contents
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Tanto para la primera y segunda fase de reducción utilizamos la medida de
 similitud entre estructuras de proteína llamada TM-score (Template Modeling
 score) 
\begin_inset CommandInset citation
LatexCommand cite
key "Zhan2004"
literal "false"

\end_inset

.
 Esta medida de similitud a diferencia de otras medidas ampliamente usadas
 en comparación de estructuras como el RMSD (Root Mean Square-Deviation)
 es más precisa ya que en el TM-score influyen poco sobre el puntaje final
 las secciones pequeñas de la proteína que alinean incorrectamente, tales
 como giros simples o términos flexibles, lo que reduce el chance de evaluacione
s sesgadas.
\end_layout

\begin_layout Subsection
Selección de Estructuras Representativas
\end_layout

\begin_layout Standard
Las estructuras representativas de cada grupo o 
\emph on
bin
\emph default
 resultante de la selección rápida de la primera fase se obtienen aplicando
 en cada uno de ellos un algoritmo de particionamiento alrededor de medoides
 (PAM) 
\begin_inset CommandInset citation
LatexCommand cite
key "Park2009"
literal "false"

\end_inset

.
 El algoritmo selecciona como representativa la estructura media o central
 de cada subgrupo resultante para la cual la suma de las distancias entre
 esta y las demás estructuras del subgrupo es mínima.
 Así, al final se obtienen por cada grupo o 
\emph on
bin
\emph default
 inicial un conjunto reducido de estructuras que representan los eventos
 principales de esta sección de la trayectoria de plegamiento.
\end_layout

\begin_layout Subsection
Trayectorias de Plegamiento de Proteínas
\begin_inset CommandInset label
LatexCommand label
name "subsec:Trayectorias-de-Plegamiento"

\end_inset


\end_layout

\begin_layout Standard
Para mostrar los resultados del algoritmo de reducción propuesto, aplicamos
 las reducciones a tres trayectorias de plegamiento de proteínas.
 La dos primeras corresponden a trayectorias cortas (200-300 conformaciones)
 para las proteínas: ferredoxina desde clostridium acidurici (PDB: 1FCA)
 y del Cyt férrico de levadura (iso-1-Cytc, PDB: 2YCC) que fueron simuladas
 por el grupo de Amato mediante el método 
\emph on
Probabilistic Roadmap Method 
\begin_inset CommandInset citation
LatexCommand cite
key "AmatoSong01"
literal "true"

\end_inset


\emph default
 y que se caracterizan por ser trayectorias cortas que tratan de incluir
 los eventos principales de la simulación.
 Por el contrario, la tercera trayectoria corresponde a la simulación de
 plegamiento mediante la técnica de Dinámica Molecular 
\begin_inset CommandInset citation
LatexCommand cite
key "Shaw2011"
literal "true"

\end_inset

 para la proteína Trp-cage (PDB: 2JOF) y se caracteriza por ser una trayectoria
 mucho más extensa y detallada (más de 1 millón de conformaciones).
\end_layout

\begin_layout Section
Detalles de Implementación (LuisG)
\end_layout

\begin_layout Subsection
Descripción de Programas
\end_layout

\begin_layout Standard
El algoritmo está implementado a través de tres scripts: 
\end_layout

\begin_layout Itemize
pr00_main.py: Script principal en lenguaje Python que toma los parámetros
 iniciales y llama a los otros scripts enviándoles los parámetros necesarios.
\end_layout

\begin_layout Itemize
pr01_createBins.py: Script en lenguaje Python que realiza las particiones
\end_layout

\begin_layout Itemize
pr02_localReduction.R : Script en lenguaje R que realiza la reducción local.
\end_layout

\begin_layout Itemize
pr03_globalReduction.R: Script en lenguaje R que realiza la reducción global.
\end_layout

\begin_layout Subsection
Ejecución
\end_layout

\begin_layout Standard
La ejecución se realiza llamando al script 
\emph on
reduction.py 
\emph default
así:
\end_layout

\begin_layout Standard
\align center

\family typewriter
$ ./reduction.py <InputDir> <Ouputdir> <BinSize> <Threshold> <K> <nCores>
\end_layout

\begin_layout Standard
Donde:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
setlist[description]{
\end_layout

\begin_layout Plain Layout

	leftmargin=
\backslash
dimexpr
\backslash
widest+0.5em
\backslash
relax,
\end_layout

\begin_layout Plain Layout

	labelindent=0pt,
\end_layout

\begin_layout Plain Layout

	style=multiline,leftmargin=10cm,
\end_layout

\begin_layout Plain Layout

	labelwidth=
\backslash
widest
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize

\series bold
Input
\begin_inset space ~
\end_inset

Dir:
\series default
 Nombre del directorio de entrada donde están las conformaciones de la trayector
ía de la proteína a reducir.
\end_layout

\begin_layout Itemize

\series bold
Output
\begin_inset space ~
\end_inset

Dir: 
\series default
Nombre del directorio donde quedarán los resultados de la reducción.
 Si el directorio ya existe lo renombra automáticamente y crea uno nuevo.
 Dentro del directorio se crean cuatro subdirectorios:
\end_layout

\begin_deeper
\begin_layout Itemize
bins: donde se crean las particiones con las conformaciones correspondientes
 a cada bin
\end_layout

\begin_layout Itemize
binsLocal: donde se crean las nuevas particiones con los resultados de la
 reducción local
\end_layout

\begin_layout Itemize
pdbsLocal donde se copian todas las conformaciones de la nueva trayectoria
 producto de la reducción local.
\end_layout

\begin_layout Itemize
pdbsGlobal: donde se copian todas las conformaciones de la nueva trayectoria
 producto de la reducción global.
\end_layout

\begin_layout Itemize
tmp: donde se coloca los archivos temporales resultantes de la creación
 de las matrices de distancia con TM-score
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Bin
\begin_inset space ~
\end_inset

Size:
\series default
 El tamaño de conformaciones por partición o 
\emph on
bin.

\emph default
 El algoritmo crea el número de 
\emph on
bins 
\emph default
dependiendo del tamaño de la trayectoria.
\end_layout

\begin_layout Itemize

\series bold
Threshold:
\series default
 Umbral usado por el TM-score para comparar dos conformaciones y decidir
 si son similares.
\end_layout

\begin_layout Itemize

\series bold
K:
\series default
 Número de conformaciones a seleccionar por el agrupamiento global
\end_layout

\begin_layout Itemize

\series bold
nCores:
\series default
 Número de 
\emph on
cores
\emph default
 a utilizar para el procesamiento en paralelo.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Para la graficación de las trayectorias está el 
\emph on
script
\emph default
 "pathway-plotting-tmscore.R", los parámetros son:
\end_layout

\begin_layout Itemize

\series bold
Native
\begin_inset space ~
\end_inset

Reference:
\series default
 Nombre del archivo de la proteína nativa a usar como referencia en las
 comparaciones con el TM-score
\end_layout

\begin_layout Itemize

\series bold
Input
\begin_inset space ~
\end_inset

Dir: 
\series default
Directorio de entrada con las conformaciones de la proteína a gráficar
\end_layout

\begin_layout Itemize

\series bold
nCores: 
\series default
Número de 
\emph on
cores
\emph default
 a utilizar para ejecutar el 
\emph on
script
\emph default
 en paralelo.
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Requisitos
\end_layout

\begin_layout Standard
Los programas están en python y en R.
 Del sistema R se necesita instalar las librería para agrupamientos y paraleliza
ción: 
\emph on
cluster 
\emph default
y 
\emph on
parallel
\emph default
, respectivamente.
\end_layout

\begin_layout Section
Resultados y Discusión
\end_layout

\begin_layout Standard
Para mostrar las reducciones que realiza nuestro algoritmo, presentamos
 aquí los resultados de la reducción realizada a tres trayectorias de proteínas.
 Las dos primeras son trayectorias cortas de menos de 300 conformaciones,
 mientras que la tercera es mucho mas larga con más de 1 millón de conformacione
s.
 
\end_layout

\begin_layout Standard
En la Figura 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:dos-trayectorias"

\end_inset

 mostramos las reducciones de las dos trayectorias cortas correspondientes
 a las proteínas 1FCA1 y 2YCC (ver sección 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Trayectorias-de-Plegamiento"

\end_inset

).
 En la parte superior está la trayectoria original completa; en la parte
 intermedia la trayectoria después de la reducción local; y en la parte
 inferior la trayectoria final después de la reducción global.
 Las reducciones logradas son del orden de más del 76% para la proteína
 1FCA1 (de 239 a 57 conformaciones) y más del 90% para la proteína 2YCC
 (de 268 a 26 conformaciones).
 Observamos que los eventos principales en ambas trayectorias se conservan
 claramente (recuadros rojos en las trayectorias original y final) lo que
 prueba visualmente que nuestro algoritmo realiza reducciones que reflejan
 la dinámica de la trayectoria.
 Además, destaquemos que en la primera reducción, la local (figura intermedia),
 los eventos principales tienden a desplazarse frente a los originales (recuadro
s azules), lo cual se logra después corregir en la reducción final.
 Esto se debe a que la reducción local por ser rápida incluye conformaciones
 tanto de eventos principales como de eventos secundarios, mientras que
 la global se enfoca en dejar solo los eventos principales y por lo tanto
 el desplazamiento se reduce, lo cual va a ser más evidente en el caso de
 la trayectoria larga descrita a continuación.
 
\end_layout

\begin_layout Standard
\align center
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A.
 1FCA1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B.
 2YCC
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "40col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename img/1FCA1-40b05t10k-ann-pdbs.pdf
	lyxscale 30
	scale 20
	BoundingBox 0bp 45bp 1008bp 445bp
	clip

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename img/1FCA1-40b05t10k-ann-pdbsLocal.pdf
	lyxscale 30
	scale 20
	BoundingBox 0bp 45bp 1008bp 465bp
	clip

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename img/1FCA1-40b05t10k-ann-pdbsGlobal.pdf
	lyxscale 30
	scale 20
	BoundingBox 0bp 10bp 1008bp 465bp

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "40col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename img/2YCC-50b05t05k-ann-pdbs.pdf
	lyxscale 30
	scale 20
	BoundingBox 0bp 45bp 1008bp 445bp
	clip

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename img/2YCC-50b05t05k-ann-pdbsLocal.pdf
	lyxscale 30
	scale 20
	BoundingBox 0bp 45bp 1008bp 465bp
	clip

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename img/2YCC-50b05t05k-ann-pdbsGlobal.pdf
	lyxscale 30
	scale 20
	BoundingBox 0bp 10bp 1008bp 465bp

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout

\series bold
Reducción de las trayectorias cortas de plegamiento para las proteínas 1FCA1
 y 2YCC
\series default
.
 
\size footnotesize
En recuadros rojos se resaltan los eventos principales que se conservan
 tanto en la trayectoria original como en la final.
 Los recuadros rojos muestran como algunos eventos principales se desplazan
 en la reducción local, pero logran ajustarse al final en la reducción global.
 Para la proteína 1FCA1 la reducción se realizó con los parámetros de 40
 bins, un umbral de TMscore de 0.5 y un K de 10.
 Mientra que para la proteína 2YCC se usaron 50 bins, un TMscore de 0.5 y
 un K de 5
\begin_inset CommandInset label
LatexCommand label
name "fig:dos-trayectorias"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Ahora, en la Figura 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:tray-2JOF-full"

\end_inset

 observamos la reducción hecha sobre una trayectoria larga de más de 1 millón
 de conformaciones para la proteína 2FOF (ver sección 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Trayectorias-de-Plegamiento"

\end_inset

).
 La reducción final fue de más del 97% (de 1044004 a 20883 conformaciones).
 Observamos que a pesar de que la simulación presenta bastantes oscilaciones
 en el plegamiento, en general los eventos principales al final de la reducción
 global se conservan.
 Es importante notar aquí que la reducción local no describe claramente
 los eventos principales, como lo destacamos en las reducciones anteriores,
 sin embargo la reducción global que toma los datos de la local, logra destacarl
os cuando selecciona las conformaciones más representativas de cada partición.
\end_layout

\begin_layout Standard
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align center
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "80col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename img/2JOF-FULL-500b04t10k-pdbs-small.pdf
	lyxscale 30
	scale 25
	BoundingBox 0bp 10bp 1440bp 465bp

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename img/2JOF-FULL-500b04t10k-pdbsLocal-small.pdf
	lyxscale 30
	scale 25
	BoundingBox 0bp 45bp 1440bp 465bp
	clip

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename img/2JOF-FULL-500b04t10k-pdbsGlobal-small.pdf
	lyxscale 30
	scale 25
	BoundingBox 0bp 10bp 1440bp 465bp

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Reducción de una trayectoria larga de plegamiento.
\begin_inset CommandInset label
LatexCommand label
name "fig:tray-2JOF-full"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Conclusiones
\end_layout

\begin_layout Standard
En este trabajo presentamos un algoritmo de reducción de trayectorias que
 visualmente produce reducciones que logran preservar la dinámica de la
 trayectoria original en cuanto a los eventos principales y la relación
 de tiempo en la que estos ocurren.
 El algoritmo tiene cuatro fases: particionamiento, reducción local, y reducción
 global.
\end_layout

\begin_layout Standard
Nuestro algoritmo es altamente configurable, se puede escoger el número
 de conformaciones de estructuras de proteínas por partición, el umbral
 de comparación entre dos conformaciones, y el número 
\emph on
K
\emph default
 para seleccionar las más representativas por partición.
 Además, el enfoque de particiones que tiene el algoritmo lo vuelve altamente
 paralelizable ya que cada reducción (local y global) se aplica de forma
 independiente, tanto local como, sobre cada una de ellas.
\end_layout

\begin_layout Standard
Usamos la métrica de TM-score en vez del RMSD para comparar las estructuras
 de proteínas.
 Aunque tradicionalemente se ha usado el RMSD, se conoce muy bien que esta
 métrica es muy sensible a pequeñas diferencias (grupos de átomos) entre
 las estructuras.
 Esas pequeñas diferencias dan como resultado grandes valores de RMSD que
 sugieren que las estructuras comparadas son muy diferentes.
 El TM-score es una métrica más robusta que el RMSD y produce mejores resultados
 a la hora de comparar estructuras de conformaciones muy cercanas, que es
 exactamente lo que se tiene cuando se comparan estructuras de conformaciones
 consecutivas en una línea de tiempo.
\end_layout

\begin_layout Standard
La implementación del algoritmo se realizó en el lenguaje R y Fortran para
 las librerías de agrupamiento y la fácil paralelización de tareas.
 En R están implementados los tres módulos: particionamiento, clustering
 local, y clustering global, mientras que en Fortran está implementada la
 rutina de evaluación del TM-score, que es la que más se llama tanto en
 el agrupamiento rápido de la reducción local, como en el agrupamiento detallado
 de la reducción local.
\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "reduccion-trayectorias"
options "plain"

\end_inset


\end_layout

\end_body
\end_document
